#+TITLE: JSEC Developer Guide
#+AUTHOR: llmII <dev@amlegion.org>
#+DATE: 2025-12-12

* Overview

This guide covers JSEC internals for contributors. JSEC provides TLS/DTLS
integration for Janet that works seamlessly with Janet's event loop (~ev~).

* Critical Constraints

** C Code Requirements

1. *ONLY use Janet's public C API* from janet.h
   - NO pthread includes or direct pthread usage
   - NO accessing Janet internal structures
   - Use Janet's locking primitives if locks needed
   - Use ~janet_malloc~ / ~janet_free~ (NOT malloc/free, NOT janet_smalloc)
   - *Exception:* Structures tied to OpenSSL ex_data callbacks use standard
     malloc/free because they are freed in OpenSSL callback context where
     Janet's allocator may not be initialized. This includes: SNIData,
     OCSPData, ALPNConfig, server_ctx_cache data.

2. *NO kludging from C to Janet code*
   - NO ~janet_resolve~, ~janet_call~, ~janet_get_method~ from C
   - If Janet doesn't export it in C API, find proper alternative

3. *NO OpenSSL initialization code*
   - OpenSSL 1.1.1+ auto-initializes
   - *Requirement:* Targets OpenSSL 3.0+ (1.1.1 is EOL)

4. *Production quality code*
   - State machine must be clear with comments
   - Event loop integration must be correct
   - Proper error handling is mandatory

** API Compatibility

1. TLS streams MUST match Janet's Stream API
   - *Difference:* Initialization (~tls/connect~ vs ~net/connect~)
   - *Identity:* All methods (~:read~, ~:write~, ~:close~) work identically

2. DTLS MUST match Janet's UDP API
   - ~dtls/listen~, ~dtls/recv-from~, ~dtls/send-to~, ~dtls/connect~

3. No features can be lost from prior versions

** Platform Strategy

*** Windows Support
- *Recommended:* MSYS2 with MinGW-w64 (UCRT64 or MINGW64)
- *CI Strategy:* GitHub Actions ~windows-latest~ runner
- *Status:* Best-effort

*** macOS Support
- *Constraint:* Author does not own Apple hardware
- *Strategy:* Community driven
- *CI Strategy:* GitHub Actions ~macos-latest~
- *Policy:* macOS-specific issues require community PRs

* Source Organization

#+begin_src
src/
├── jtls/                    # TLS implementation
│   ├── types.c              # TLSStream type, GC, methods
│   ├── api/                 # Public API functions
│   │   ├── context.c        # tls/new-context
│   │   ├── connect.c        # tls/connect
│   │   ├── listen.c         # tls/listen, tls/accept
│   │   └── upgrade.c        # tls/upgrade (STARTTLS)
│   └── internal/            # Internal implementation
│       ├── handshake.c      # Async handshake state machine
│       └── io.c             # Async read/write
├── jdtls/                   # DTLS implementation
│   ├── client.c             # DTLS client
│   ├── server.c             # DTLS server with multi-client
│   ├── session.c            # Session management
│   └── address.c            # Address abstraction
├── jca/                     # Certificate Authority
│   ├── types.c              # CA type definition
│   ├── sign.c               # CSR signing
│   ├── crl.c                # CRL generation
│   └── ocsp.c               # OCSP responder
├── jcrypto/                 # Cryptographic operations
├── jutils/                  # Shared utilities
│   ├── context.c            # Unified SSL_CTX handling
│   ├── security.c           # Security option parsing
│   └── panic.c              # Error handling macros
├── jbio.c                   # Memory BIO operations
├── jcert/
│   ├── jcert.c                  # Certificate generation
#+end_src

* TLS State Machine

** States

#+begin_src c
typedef enum {
    TLS_STATE_INIT,           /* Initial state after wrap */
    TLS_STATE_HANDSHAKE,      /* Handshake in progress */
    TLS_STATE_READY,          /* Handshake complete, ready for I/O */
    TLS_STATE_SHUTDOWN,       /* Shutdown in progress */
    TLS_STATE_ERROR,          /* Unrecoverable error */
    TLS_STATE_CLOSED          /* Connection closed */
} tls_state_t;
#+end_src

** State Transitions

#+begin_src
                    ┌─────────────────────────────────────────┐
                    │                                         │
                    v                                         │
    ┌──────────┐   wrap    ┌───────────────┐                  │
    │   INIT   │ ────────> │  HANDSHAKE    │ ─── error ───────┤
    └──────────┘           └───────────────┘                  │
                                  │                           │
                           SSL_do_handshake()                 │
                                  │                           │
                           ┌──────┴──────┐                    │
                           │             │                    │
                     WANT_READ     WANT_WRITE                 │
                           │             │                    │
                           │   (wait for event,               │
                           │    retry handshake)              │
                           │             │                    │
                           └──────┬──────┘                    │
                                  │                           │
                              success                         │
                                  │                           │
                                  v                           │
                           ┌───────────────┐                  │
                           │    READY      │ ─── error ───────┤
                           └───────────────┘                  │
                                  │                           │
                             ev/close                         │
                                  │                           │
                                  v                           │
                           ┌───────────────┐                  │
                           │   SHUTDOWN    │ ─── error ───────┤
                           └───────────────┘                  │
                                  │                           │
                           SSL_shutdown()                     │
                           (bidirectional)                    │
                                  │                           │
                                  v                           │
                           ┌───────────────┐      ┌─────────┐ │
                           │    CLOSED     │      │  ERROR  │<┘
                           └───────────────┘      └─────────┘
#+end_src

** SSL_ERROR Handling

When OpenSSL returns an error, check ~SSL_get_error()~:

| SSL_ERROR             | Action                                     |
|-----------------------+--------------------------------------------|
| SSL_ERROR_NONE        | Operation completed successfully           |
| SSL_ERROR_WANT_READ   | Register for read event, retry when ready  |
| SSL_ERROR_WANT_WRITE  | Register for write event, retry when ready |
| SSL_ERROR_ZERO_RETURN | Clean shutdown received (EOF)              |
| SSL_ERROR_SYSCALL     | Check errno; usually connection reset      |
| SSL_ERROR_SSL         | Protocol error; check ERR_get_error()      |

* Event Loop Integration

JSEC uses Janet's ~janet_async_start()~ / ~janet_async_end()~ API for async I/O.

** The Async Pattern

#+begin_src c
/* 1. Start async operation */
JanetAsyncHandle handle = janet_async_start(
    stream,              /* The Janet stream */
    JANET_ASYNC_READ,    /* Event type */
    &read_cb,            /* Callback struct */
    state                /* User state */
);

/* 2. Callback is invoked when event occurs */
static void read_callback(JanetAsyncHandle handle, JanetAsyncEvent event) {
    switch (event) {
        case JANET_ASYNC_EVENT_READ:
            /* Socket is readable, try SSL_read */
            ret = SSL_read(ssl, buf, n);
            if (ret > 0) {
                /* Success! Schedule fiber with result */
                janet_async_end(handle, janet_wrap_buffer(buf));
            } else {
                int err = SSL_get_error(ssl, ret);
                if (err == SSL_ERROR_WANT_READ) {
                    /* Need more data, stay registered */
                    return;
                } else if (err == SSL_ERROR_WANT_WRITE) {
                    /* Renegotiation needs write */
                    janet_async_mod(handle, JANET_ASYNC_WRITE);
                    return;
                }
                /* Error - schedule fiber with error */
                janet_async_end(handle, janet_wrap_nil());
            }
            break;
        case JANET_ASYNC_EVENT_CANCEL:
            /* Fiber was cancelled */
            janet_async_end(handle, janet_wrap_nil());
            break;
    }
}
#+end_src

** Key Functions

- ~janet_async_start()~ - Begin async operation, fiber yields
- ~janet_async_end()~ - Complete operation, fiber resumes with value
- ~janet_async_mod()~ - Change event registration (READ <-> WRITE)

** Why WANT_WRITE During Read?

TLS can renegotiate at any time. During a read, OpenSSL may need to send
a handshake message, returning ~SSL_ERROR_WANT_WRITE~. We must:

1. Switch to write event registration
2. When writable, retry the *same* SSL_read() call
3. OpenSSL handles the renegotiation transparently

* Memory Management

** OpenSSL Objects

- ~SSL_CTX~ - Reference counted, can be shared across connections
- ~SSL~ - One per connection, freed on stream close
- ~BIO~ - Managed by SSL when attached, freed automatically

** Janet Integration

- Streams are garbage collected via ~gc~ callback
- Use ~janet_gcroot()~ / ~janet_gcunroot()~ for persistent references
- Always clean up OpenSSL state in ~gc~ callback

** Error Path Cleanup

Use goto cleanup pattern consistently:

#+begin_src c
static Janet cfun_something(int32_t argc, Janet *argv) {
    X509 *cert = NULL;
    EVP_PKEY *key = NULL;
    BIO *bio = NULL;

    cert = X509_new();
    if (!cert) goto cleanup;

    key = EVP_PKEY_new();
    if (!key) goto cleanup;

    /* ... success path ... */
    return result;

cleanup:
    if (cert) X509_free(cert);
    if (key) EVP_PKEY_free(key);
    if (bio) BIO_free(bio);
    janet_panic("operation failed");
}
#+end_src

* Adding New Functionality

** Adding a Stream Method

1. Add method function in ~jtls/types.c~:
   #+begin_src c
   static Janet method_foo(int32_t argc, Janet *argv) {
       janet_fixarity(argc, 1);
       TLSStream *tls = get_tls_stream(argv[0]);
       /* implementation */
       return janet_wrap_nil();
   }
   #+end_src

2. Add to methods table:
   #+begin_src c
   static const JanetMethod tls_stream_methods[] = {
       {"foo", method_foo},
       /* ... */
       {NULL, NULL}
   };
   #+end_src

** Adding a Module Function

1. Add function in appropriate file:
   #+begin_src c
   static Janet cfun_something(int32_t argc, Janet *argv) {
       /* implementation */
   }
   #+end_src

2. Add to module registration:
   #+begin_src c
   static const JanetReg tls_cfuns[] = {
       {"tls/something", cfun_something, "(tls/something ...)\n\nDocs"},
       {NULL, NULL, NULL}
   };
   #+end_src

* Building and Debugging

** Build with Debug Symbols

#+begin_src bash
jpm clean
jpm build -- -O0 -g
#+end_src

** OpenSSL Error Messages

#+begin_src c
#include <openssl/err.h>

/* Print all queued errors */
ERR_print_errors_fp(stderr);

/* Get single error */
unsigned long err = ERR_get_error();
char buf[256];
ERR_error_string_n(err, buf, sizeof(buf));
fprintf(stderr, "OpenSSL error: %s\n", buf);
#+end_src

** Useful Tools

- ~strace -f -e trace=network~ - Trace network syscalls
- ~openssl s_client -connect host:port~ - Test server
- ~openssl s_server -cert cert.pem -key key.pem~ - Test client
- ~wireshark~ - Packet inspection (can decrypt with SSLKEYLOGFILE)

* Common Pitfalls

1. *Blocking in Event Loop* - Never use blocking OpenSSL calls
2. *Ignoring WANT_READ/WANT_WRITE* - Must handle renegotiation
3. *Memory Leaks* - Always free SSL/SSL_CTX in gc callback
4. *Missing Error Checks* - Always check SSL_get_error() return
5. *Thread Safety* - OpenSSL 1.1.1+ is thread-safe, but not Janet streams

* References

- [[https://janet-lang.org/capi/index.html][Janet C API Documentation]]
- [[https://www.openssl.org/docs/man3.0/man3/][OpenSSL 3.0 Manual]]
